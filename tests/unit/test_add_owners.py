import os
import unittest

from eth_typing import URI
from gnosis.eth import EthereumClient
from web3 import Web3

from src.add_owner import (
    build_add_owner_with_threshold,
    AddOwnerArgs,
)
from src.multisend import build_and_sign_multisend
from src.safe import get_safe


class TestMultiAddOwner(unittest.TestCase):
    def setUp(self) -> None:
        self.client = EthereumClient(URI("https://rpc.gnosischain.com"))
        self.parent = get_safe(
            "0x206a9EAa7d0f9637c905F2Bf86aCaB363Abb418c", self.client
        )
        self.new_owner = Web3.to_checksum_address(
            "0x262d23a2d916f6CF08e0235315aA51E22d142d0b"
        )

        self.sub_safes = list(
            map(
                lambda a: get_safe(a, self.client),
                [
                    "0x8baf303407eb4ea42f18bdec84f7d3bbe48c9046",
                    "0xabe0ce1df666042e950f6f3984522d88e158a50d",
                    "0xea0e39ebcd62e7d9dd659ab936f4fd480ae8594c",
                ],
            )
        )

    def test_build_add_owner_singleton_fails_with_invalid_transaction(self):
        invalid_sub_safe = get_safe(
            "0xef7fe7fb0e281d82d49b22c6d05d2ce22bb6801f", self.client
        )
        with self.assertRaises(AssertionError) as err:
            build_add_owner_with_threshold(
                safe=self.parent,
                sub_safe=invalid_sub_safe,
                params=AddOwnerArgs(self.new_owner, 1),
            )
        self.assertEqual(
            str(err.exception), f"{self.parent} not an owner of {invalid_sub_safe}"
        )

    def test_build_add_owner_singleton_works_for_valid_input(self):
        tx = build_add_owner_with_threshold(
            safe=self.parent,
            sub_safe=self.sub_safes[0],
            params=AddOwnerArgs(self.new_owner, 1),
        )
        expected = (
            "0x6a761202"
            "0000000000000000000000008baf303407eb4ea42f18bdec84f7d3bbe48c9046"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000140"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "00000000000000000000000000000000000000000000000000000000000001c0"
            "00000000000000000000000000000000000000000000000000000000000000"
            "440d582f13"
            "000000000000000000000000262d23a2d916f6cf08e0235315aa51e22d142d0b"
            "0000000000000000000000000000000000000000000000000000000000000001"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000004100000000"
            "0000000000000000206a9eaa7d0f9637c905f2bf86acab363abb418c00000000"
            "0000000000000000000000000000000000000000000000000000000001000000"
            "00000000000000000000000000000000000000000000000000000000"
        )
        self.assertEqual(expected, tx.data.hex())

    def test_multi_add_owner(self):
        # Verify against this existing TX:
        # https://blockscout.com/xdai/mainnet/tx/0x173aa03ca15541f7544d3c1900734c56d7f49a56d47fc79e386a80e709049e22/
        # Can also check the safe interface (nonce 110) for this:
        # https://gnosis-safe.io/app/gno:0x206a9EAa7d0f9637c905F2Bf86aCaB363Abb418c/transactions/history
        tx = build_and_sign_multisend(
            safe=self.parent,
            transactions=[
                build_add_owner_with_threshold(
                    safe=self.parent,
                    # Unfortunate thing about having this so deeply nested
                    # is that we can't log about the loaded child safes:
                    # functional programming ftw
                    sub_safe=child,
                    params=AddOwnerArgs(self.new_owner, 1),
                )
                for child in self.sub_safes
            ],
            client=self.client,
            signing_key="0" * 64,
        )
        expected = (
            "0x8d80ff0a"
            "0000000000000000000000000000000000000000000000000000000000000020"
            "00000000000000000000000000000000000000000000000000000000000007cb"
            "008baf303407eb4ea42f18bdec84f7d3bbe48c90460000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000002446a76120200000000000000"
            "00000000008baf303407eb4ea42f18bdec84f7d3bbe48c904600000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000014000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000001c000000000000000"
            "000000000000000000000000000000000000000000000000440d582f13000000"
            "000000000000000000262d23a2d916f6cf08e0235315aa51e22d142d0b000000"
            "0000000000000000000000000000000000000000000000000000000001000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000004100000000000000"
            "0000000000206a9eaa7d0f9637c905f2bf86acab363abb418c00000000000000"
            "0000000000000000000000000000000000000000000000000001000000000000"
            "0000000000000000000000000000000000000000000000000000abe0ce1df666"
            "042e950f6f3984522d88e158a50d000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "00000000000000000000000002446a761202000000000000000000000000abe0"
            "ce1df666042e950f6f3984522d88e158a50d0000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000001400000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000001c00000000000000000000000000000"
            "0000000000000000000000000000000000440d582f1300000000000000000000"
            "0000262d23a2d916f6cf08e0235315aa51e22d142d0b00000000000000000000"
            "0000000000000000000000000000000000000000000100000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000041000000000000000000000000206a"
            "9eaa7d0f9637c905f2bf86acab363abb418c0000000000000000000000000000"
            "0000000000000000000000000000000000000100000000000000000000000000"
            "00000000000000000000000000000000000000ea0e39ebcd62e7d9dd659ab936"
            "f4fd480ae8594c00000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "000000000002446a761202000000000000000000000000ea0e39ebcd62e7d9dd"
            "659ab936f4fd480ae8594c000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000140000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "00000000000000000001c0000000000000000000000000000000000000000000"
            "00000000000000000000440d582f13000000000000000000000000262d23a2d9"
            "16f6cf08e0235315aa51e22d142d0b0000000000000000000000000000000000"
            "0000000000000000000000000000010000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000041000000000000000000000000206a9eaa7d0f9637c9"
            "05f2bf86acab363abb418c000000000000000000000000000000000000000000"
            "0000000000000000000000010000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000"
        )
        self.assertEqual(expected, tx.data.hex())
        # TODO - Fetch Tx Data directly from on chain by txHash and compare.
        # Should also be able to get it from existing_tx, but there is some execTransaction
        # stuff put at the front

        # This is not quite working yet (could have something to do with nonce or ZERO_ADDRESS)
        # existing_tx = Web3(Web3.HTTPProvider(NODE_URL)).eth.getTransaction(
        #     "0x173aa03ca15541f7544d3c1900734c56d7f49a56d47fc79e386a80e709049e22"
        # )
        # Note: Type issue here (because of homemade SafeTransaction class
        # full_data = encode_exec_transaction(self.parent, ZERO_ADDRESS, tx)
        # self.assertEqual(existing_tx["data"], full_data)
